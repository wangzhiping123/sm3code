#include <stdint.h>
#include <string.h>
#include <stdio.h>

// 常量定义
#define SM3_BLOCK_SIZE 64
#define SM3_DIGEST_SIZE 32

// 初始化向量
static const uint32_t IV[8] = {
    0x7380166F, 0x4914B2B9, 0x172442D7, 0xDA8A0600,
    0xA96F30BC, 0x163138AA, 0xE38DEE4D, 0xB0FB0E4E
};

// 循环左移函数
static uint32_t rotate_left(uint32_t x, int n) {
    return (x << n) | (x >> (32 - n));
}

// 压缩函数中的布尔函数
#define FF0(x, y, z) (x ^ y ^ z)
#define FF1(x, y, z) ((x & y) | (x & z) | (y & z))
#define GG0(x, y, z) (x ^ y ^ z)
#define GG1(x, y, z) ((x & y) | (~x & z))

// 压缩函数中的置换函数
#define P0(x) (x ^ rotate_left(x, 9) ^ rotate_left(x, 17))
#define P1(x) (x ^ rotate_left(x, 15) ^ rotate_left(x, 23))

// 常量T
static const uint32_t T[64] = {
    0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519,
    0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519,
    0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A,
    0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A,
    0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A,
    0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A,
    0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A,
    0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A
};

// 压缩函数
static void sm3_compress(uint32_t digest[8], const uint8_t block[SM3_BLOCK_SIZE]) {
    uint32_t W[68], W1[64];
    uint32_t A, B, C, D, E, F, G, H;
    uint32_t SS1, SS2, TT1, TT2;
    int i;

    // 消息扩展
    for (i = 0; i < 16; i++) {
        W[i] = (block[4 * i] << 24) | (block[4 * i + 1] << 16) | (block[4 * i + 2] << 8) | block[4 * i + 3];
    }
    for (i = 16; i < 68; i++) {
        W[i] = P1(W[i - 16] ^ W[i - 9] ^ rotate_left(W[i - 3], 15)) ^ rotate_left(W[i - 13], 7) ^ W[i - 6];
    }
    for (i = 0; i < 64; i++) {
        W1[i] = W[i] ^ W[i + 4];
    }

    // 初始化工作变量
    A = digest[0];
    B = digest[1];
    C = digest[2];
    D = digest[3];
    E = digest[4];
    F = digest[5];
    G = digest[6];
    H = digest[7];

    // 64轮迭代
    for (i = 0; i < 64; i++) {
        SS1 = rotate_left((rotate_left(A, 12) + E + rotate_left(T[i], i)), 7);
        SS2 = SS1 ^ rotate_left(A, 12);
        TT1 = (i < 16 ? FF0(A, B, C) : FF1(A, B, C)) + D + SS2 + W1[i];
        TT2 = (i < 16 ? GG0(E, F, G) : GG1(E, F, G)) + H + SS1 + W[i];
        D = C;
        C = rotate_left(B, 9);
        B = A;
        A = TT1;
        H = G;
        G = rotate_left(F, 19);
        F = E;
        E = P0(TT2);
    }

    // 更新摘要值
    digest[0] ^= A;
    digest[1] ^= B;
    digest[2] ^= C;
    digest[3] ^= D;
    digest[4] ^= E;
    digest[5] ^= F;
    digest[6] ^= G;
    digest[7] ^= H;
}

// 初始化SM3上下文
void sm3_init(uint32_t digest[8], uint64_t* length, uint8_t buffer[SM3_BLOCK_SIZE]) {
    memcpy(digest, IV, 8 * sizeof(uint32_t));
    *length = 0;
    memset(buffer, 0, SM3_BLOCK_SIZE);
}

// 更新SM3上下文
void sm3_update(uint32_t digest[8], uint64_t* length, uint8_t buffer[SM3_BLOCK_SIZE], const uint8_t* data, size_t data_len) {
    size_t i;
    for (i = 0; i < data_len; i++) {
        buffer[*length % SM3_BLOCK_SIZE] = data[i];
        (*length)++;
        if (*length % SM3_BLOCK_SIZE == 0) {
            sm3_compress(digest, buffer);
            memset(buffer, 0, SM3_BLOCK_SIZE);
        }
    }
}

// 完成SM3计算
void sm3_final(uint32_t digest[8], uint64_t* length, uint8_t buffer[SM3_BLOCK_SIZE], uint8_t hash[SM3_DIGEST_SIZE]) {
    size_t pos = *length % SM3_BLOCK_SIZE;
    buffer[pos++] = 0x80;  // 添加填充位

    // 如果剩余空间不足8字节(存储长度)，则先压缩当前块
    if (pos > SM3_BLOCK_SIZE - 8) {
        memset(buffer + pos, 0, SM3_BLOCK_SIZE - pos);
        sm3_compress(digest, buffer);
        memset(buffer, 0, SM3_BLOCK_SIZE);
        pos = 0;
    }

    // 填充0
    memset(buffer + pos, 0, SM3_BLOCK_SIZE - pos - 8);

    // 存储消息总长度(bit)
    uint64_t bit_length = *length * 8;
    buffer[SM3_BLOCK_SIZE - 8] = (bit_length >> 56) & 0xFF;
    buffer[SM3_BLOCK_SIZE - 7] = (bit_length >> 48) & 0xFF;
    buffer[SM3_BLOCK_SIZE - 6] = (bit_length >> 40) & 0xFF;
    buffer[SM3_BLOCK_SIZE - 5] = (bit_length >> 32) & 0xFF;
    buffer[SM3_BLOCK_SIZE - 4] = (bit_length >> 24) & 0xFF;
    buffer[SM3_BLOCK_SIZE - 3] = (bit_length >> 16) & 0xFF;
    buffer[SM3_BLOCK_SIZE - 2] = (bit_length >> 8) & 0xFF;
    buffer[SM3_BLOCK_SIZE - 1] = bit_length & 0xFF;

    // 压缩最后一块
    sm3_compress(digest, buffer);

    // 将结果转换为字节数组
    for (int i = 0; i < 8; i++) {
        hash[4 * i] = (digest[i] >> 24) & 0xFF;
        hash[4 * i + 1] = (digest[i] >> 16) & 0xFF;
        hash[4 * i + 2] = (digest[i] >> 8) & 0xFF;
        hash[4 * i + 3] = digest[i] & 0xFF;
    }
}

// 便捷函数：直接计算数据的SM3哈希
void sm3_hash(const uint8_t* data, size_t data_len, uint8_t hash[SM3_DIGEST_SIZE]) {
    uint32_t digest[8];
    uint64_t length;
    uint8_t buffer[SM3_BLOCK_SIZE];

    sm3_init(digest, &length, buffer);
    sm3_update(digest, &length, buffer, data, data_len);
    sm3_final(digest, &length, buffer, hash);
}

// 测试函数
int main() {
    // 测试向量1：空字符串
    uint8_t hash1[SM3_DIGEST_SIZE];
    sm3_hash((const uint8_t*)"", 0, hash1);  // 增加强制类型转换
    printf("空字符串哈希: ");
    for (int i = 0; i < SM3_DIGEST_SIZE; i++) {
        printf("%02x", hash1[i]);
    }
    printf("\n");

    // 测试向量2："abc"
    uint8_t hash2[SM3_DIGEST_SIZE];
    const char* str2 = "abc";
    sm3_hash((const uint8_t*)str2, strlen(str2), hash2); // 增加强制类型转换
    printf("\"abc\"哈希:   ");
    for (int i = 0; i < SM3_DIGEST_SIZE; i++) {
        printf("%02x", hash2[i]);
    }
    printf("\n");

    return 0;
}
