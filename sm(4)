#include <stdint.h>
#include <string.h>
#include <stdio.h>

// 常量定义
#define SM3_BLOCK_SIZE 64
#define SM3_DIGEST_SIZE 32

// 初始化向量
static const uint32_t IV[8] = {
    0x7380166F, 0x4914B2B9, 0x172442D7, 0xDA8A0600,
    0xA96F30BC, 0x163138AA, 0xE38DEE4D, 0xB0FB0E4E
};

// 循环左移函数
static uint32_t rotate_left(uint32_t x, int n) {
    return (x << n) | (x >> (32 - n));
}

// 压缩函数中的布尔函数
#define FF0(x, y, z) (x ^ y ^ z)
#define FF1(x, y, z) ((x & y) | (x & z) | (y & z))
#define GG0(x, y, z) (x ^ y ^ z)
#define GG1(x, y, z) ((x & y) | (~x & z))

// 压缩函数中的置换函数
#define P0(x) (x ^ rotate_left(x, 9) ^ rotate_left(x, 17))
#define P1(x) (x ^ rotate_left(x, 15) ^ rotate_left(x, 23))

// 常量T
static const uint32_t T[64] = {
    0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519,
    0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519, 0x79CC4519,
    0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A,
    0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A,
    0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A,
    0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A,
    0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A,
    0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A, 0x7A879D8A
};

// 压缩函数
static void sm3_compress(uint32_t digest[8], const uint8_t block[SM3_BLOCK_SIZE]) {
    uint32_t W[68], W1[64];
    uint32_t A, B, C, D, E, F, G, H;
    uint32_t SS1, SS2, TT1, TT2;
    int i;

    // 消息扩展
    for (i = 0; i < 16; i++) {
        W[i] = (block[4 * i] << 24) | (block[4 * i + 1] << 16) | (block[4 * i + 2] << 8) | block[4 * i + 3];
    }
    for (i = 16; i < 68; i++) {
        W[i] = P1(W[i - 16] ^ W[i - 9] ^ rotate_left(W[i - 3], 15)) ^ rotate_left(W[i - 13], 7) ^ W[i - 6];
    }
    for (i = 0; i < 64; i++) {
        W1[i] = W[i] ^ W[i + 4];
    }

    // 初始化工作变量
    A = digest[0];
    B = digest[1];
    C = digest[2];
    D = digest[3];
    E = digest[4];
    F = digest[5];
    G = digest[6];
    H = digest[7];

    // 64轮迭代
    for (i = 0; i < 64; i++) {
        SS1 = rotate_left((rotate_left(A, 12) + E + rotate_left(T[i], i)), 7);
        SS2 = SS1 ^ rotate_left(A, 12);
        TT1 = (i < 16 ? FF0(A, B, C) : FF1(A, B, C)) + D + SS2 + W1[i];
        TT2 = (i < 16 ? GG0(E, F, G) : GG1(E, F, G)) + H + SS1 + W[i];
        D = C;
        C = rotate_left(B, 9);
        B = A;
        A = TT1;
        H = G;
        G = rotate_left(F, 19);
        F = E;
        E = P0(TT2);
    }

    // 更新摘要值
    digest[0] ^= A;
    digest[1] ^= B;
    digest[2] ^= C;
    digest[3] ^= D;
    digest[4] ^= E;
    digest[5] ^= F;
    digest[6] ^= G;
    digest[7] ^= H;
}

// 初始化SM3上下文
void sm3_init(uint32_t digest[8], uint64_t* length, uint8_t buffer[SM3_BLOCK_SIZE]) {
    memcpy(digest, IV, 8 * sizeof(uint32_t));
    *length = 0;
    memset(buffer, 0, SM3_BLOCK_SIZE);
}

// 更新SM3上下文
void sm3_update(uint32_t digest[8], uint64_t* length, uint8_t buffer[SM3_BLOCK_SIZE], const uint8_t* data, size_t data_len) {
    size_t i;
    for (i = 0; i < data_len; i++) {
        buffer[*length % SM3_BLOCK_SIZE] = data[i];
        (*length)++;
        if (*length % SM3_BLOCK_SIZE == 0) {
            sm3_compress(digest, buffer);
            memset(buffer, 0, SM3_BLOCK_SIZE);
        }
    }
}

// 完成SM3计算
void sm3_final(uint32_t digest[8], uint64_t* length, uint8_t buffer[SM3_BLOCK_SIZE], uint8_t hash[SM3_DIGEST_SIZE]) {
    size_t pos = *length % SM3_BLOCK_SIZE;
    buffer[pos++] = 0x80;  // 添加填充位

    // 如果剩余空间不足8字节(存储长度)，则先压缩当前块
    if (pos > SM3_BLOCK_SIZE - 8) {
        memset(buffer + pos, 0, SM3_BLOCK_SIZE - pos);
        sm3_compress(digest, buffer);
        memset(buffer, 0, SM3_BLOCK_SIZE);
        pos = 0;
    }

    // 填充0
    memset(buffer + pos, 0, SM3_BLOCK_SIZE - pos - 8);

    // 存储消息总长度(bit)
    uint64_t bit_length = *length * 8;
    buffer[SM3_BLOCK_SIZE - 8] = (bit_length >> 56) & 0xFF;
    buffer[SM3_BLOCK_SIZE - 7] = (bit_length >> 48) & 0xFF;
    buffer[SM3_BLOCK_SIZE - 6] = (bit_length >> 40) & 0xFF;
    buffer[SM3_BLOCK_SIZE - 5] = (bit_length >> 32) & 0xFF;
    buffer[SM3_BLOCK_SIZE - 4] = (bit_length >> 24) & 0xFF;
    buffer[SM3_BLOCK_SIZE - 3] = (bit_length >> 16) & 0xFF;
    buffer[SM3_BLOCK_SIZE - 2] = (bit_length >> 8) & 0xFF;
    buffer[SM3_BLOCK_SIZE - 1] = bit_length & 0xFF;

    // 压缩最后一块
    sm3_compress(digest, buffer);

    // 将结果转换为字节数组
    for (int i = 0; i < 8; i++) {
        hash[4 * i] = (digest[i] >> 24) & 0xFF;
        hash[4 * i + 1] = (digest[i] >> 16) & 0xFF;
        hash[4 * i + 2] = (digest[i] >> 8) & 0xFF;
        hash[4 * i + 3] = digest[i] & 0xFF;
    }
}

// 便捷函数：直接计算数据的SM3哈希
void sm3_hash(const uint8_t* data, size_t data_len, uint8_t hash[SM3_DIGEST_SIZE]) {
    uint32_t digest[8];
    uint64_t length;
    uint8_t buffer[SM3_BLOCK_SIZE];

    sm3_init(digest, &length, buffer);
    sm3_update(digest, &length, buffer, data, data_len);
    sm3_final(digest, &length, buffer, hash);
}

// 创建测试文件
void create_test_file(const char* filename, const char* content, size_t length) {
    FILE* file = fopen(filename, "wb");
    if (file) {
        fwrite(content, 1, length, file);
        fclose(file);
    }
}

// 计算文件哈希
void sm3_file_hash(const char* filename, uint8_t hash[SM3_DIGEST_SIZE]) {
    FILE* file = fopen(filename, "rb");
    if (!file) {
        printf("无法打开文件: %s\n", filename);
        return;
    }

    uint32_t digest[8];
    uint64_t length = 0;
    uint8_t buffer[SM3_BLOCK_SIZE];
    
    sm3_init(digest, &length, buffer);
    
    size_t bytes_read;
    while ((bytes_read = fread(buffer, 1, SM3_BLOCK_SIZE, file)) > 0) {
        sm3_update(digest, &length, buffer, buffer, bytes_read);
    }
    
    sm3_final(digest, &length, buffer, hash);
    fclose(file);
}

// 打印哈希值
void print_hash(const char* label, const uint8_t hash[SM3_DIGEST_SIZE]) {
    printf("%s: ", label);
    for (int i = 0; i < SM3_DIGEST_SIZE; i++) {
        printf("%02x", hash[i]);
    }
    printf("\n");
}

// 测试函数
int main() {
    printf("=== SM3哈希算法边界用例验证 ===\n\n");

    // 测试向量1：空字符串
    uint8_t hash1[SM3_DIGEST_SIZE];
    sm3_hash((const uint8_t*)"", 0, hash1);
    print_hash("空字符串哈希", hash1);

    // 边界用例1：空文件输入
    printf("\n1. 空文件输入验证:\n");
    create_test_file("empty.txt", "", 0);
    uint8_t file_hash1[SM3_DIGEST_SIZE];
    sm3_file_hash("empty.txt", file_hash1);
    print_hash("空文件哈希", file_hash1);
    
    // 验证空文件与空字符串哈希一致
    if (memcmp(hash1, file_hash1, SM3_DIGEST_SIZE) == 0) {
        printf("✓ 空文件与空字符串哈希一致\n");
    } else {
        printf("✗ 空文件与空字符串哈希不一致\n");
    }

    // 边界用例2：1字节输入
    printf("\n2. 1字节输入验证:\n");
    const char* one_byte = "a";
    uint8_t hash_one_byte[SM3_DIGEST_SIZE];
    sm3_hash((const uint8_t*)one_byte, 1, hash_one_byte);
    print_hash("1字节输入哈希", hash_one_byte);
    printf("输入: '%s' (1字节, 8bit)\n", one_byte);
    printf("填充后数据块: 512bit (64字节)\n");

    // 边界用例3：448bit(56字节)输入
    printf("\n3. 448bit(56字节)输入验证:\n");
    char data_56bytes[57]; // 56个'a' + 空字符
    memset(data_56bytes, 'a', 56);
    data_56bytes[56] = '\0';
    
    uint8_t hash_56bytes[SM3_DIGEST_SIZE];
    sm3_hash((const uint8_t*)data_56bytes, 56, hash_56bytes);
    print_hash("56字节输入哈希", hash_56bytes);
    printf("输入长度: 56字节 (448bit)\n");
    printf("填充后数据块: 512bit (64字节)\n");
    printf("输入内容: %.20s...\n", data_56bytes);

    // 边界用例4：多分组输入(1024字节)
    printf("\n4. 多分组输入验证(1024字节):\n");
    char data_1024bytes[1025];
    memset(data_1024bytes, 'x', 1024);
    data_1024bytes[1024] = '\0';
    
    uint8_t hash_1024bytes[SM3_DIGEST_SIZE];
    sm3_hash((const uint8_t*)data_1024bytes, 1024, hash_1024bytes);
    print_hash("1024字节输入哈希", hash_1024bytes);
    printf("输入长度: 1024字节\n");
    printf("数据块数量: %d 个\n", 1024 / SM3_BLOCK_SIZE);
    printf("输入内容: %.20s...\n", data_1024bytes);

    // 标准测试用例
    printf("\n=== 标准测试用例 ===\n");
    
    // 测试向量2："abc"
    uint8_t hash2[SM3_DIGEST_SIZE];
    const char* str2 = "abc";
    sm3_hash((const uint8_t*)str2, strlen(str2), hash2);
    print_hash("\"abc\"哈希", hash2);

    // 测试向量3：长字符串
    uint8_t hash3[SM3_DIGEST_SIZE];
    const char* str3 = "abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd";
    sm3_hash((const uint8_t*)str3, strlen(str3), hash3);
    print_hash("长字符串哈希", hash3);
    printf("长字符串长度: %zu 字节\n", strlen(str3));

    printf("\n=== 边界用例验证完成 ===\n");
    return 0;
}
